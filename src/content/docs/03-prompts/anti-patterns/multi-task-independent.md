---
title: 一条消息塞进彼此不依赖的多任务
description: 把正交子任务强行塞进同一条提示，既浪费上下文预算，也拉低质量与吞吐。
tab:
  label: 多任务但彼此不依赖
  order: 35
contributors:
  - codex
---

## 症状
- 在一条提示里要求“分析 + 改写 + 翻译 + 画图 + 写 SQL”等，且这些任务之间并无数据/结论依赖。
- 结果常见漏项、顺序错乱、细节浅，或模型只做了其中一部分。

## 为什么不好
- 编排失当：无依赖的子任务属于 DAG 的并列节点，被强行串行执行，注意力被稀释，采样空间被拉扯。
- 成本与质量：上下文冗余、指令冲突概率上升；生成被“平均用力”，边界用例被忽略。

## 改法（工程化）
1) 先做任务依赖图（DAG），区分“依赖型”和“正交型”子任务。
2) 依赖型任务按 stage 推进，每个 stage 产出可验证的中间产物（结构化）。
3) 正交型任务并行：用“干净上下文”分别启动各子任务，避免在一条消息里强行混装。
4) 跨 stage 只传中间产物（schema 化），不要漫灌全文上下文。

## 好例（两阶段 + 并行）
- Stage 1（依赖）：生成数据清洗脚本（输出：脚本 + 单测通过截图）。
- Stage 2（正交，并行）：
  - 子任务 A：基于清洗后数据生成可视化方案 A；
  - 子任务 B：生成可视化方案 B；
- 汇总：比较 A/B 的优劣并给出决策建议。

## 模板（可复制）
```md
目标：将任务拆为若干 stage，stage 内部识别“正交子任务”，分别在干净上下文中并行执行。

Stage k：
- 输入：{上个 stage 的中间产物（结构化）}
- 子任务（正交）：
  1) {任务 A：输入、输出结构、约束}
  2) {任务 B：输入、输出结构、约束}
- 汇总：
  - 输出结构：{比较维度、结论、下一步}
```

## 评估指标
- 吞吐：总 tokens / 总时长下降；
- 质量：子任务漏项率下降；
- 可复现：中间产物可独立复验；
- 并行占比：正交子任务并行执行的比例提升。
