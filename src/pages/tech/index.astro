---
import ContentLayout from '../../layouts/ContentPageLayout.astro';

const section = '技术向';
const currentPage = 'tech';
const title = '技术向 - 大模型应用开发的基石';
const sidebarContent = `
  <a href="/tech" class="active">技术向概述</a>
  <a href="/tech/providers">主流服务商</a>
  <a href="/tech/management">密钥管理</a>
  <a href="/tech/security">安全最佳实践</a>
  <a href="/tech/cost-optimization">成本优化</a>
  <a href="/tech/monitoring">监控与告警</a>
`;
const headings = [
  { id: 'introduction', text: '介绍', depth: 1 },
  { id: 'importance', text: 'API密钥的重要性', depth: 1 },
  { id: 'types', text: '密钥类型与权限', depth: 1 },
  { id: 'lifecycle', text: '密钥生命周期', depth: 1 },
  { id: 'common-issues', text: '常见问题', depth: 1 },
  { id: 'getting-started', text: '快速上手指南', depth: 1 }
];
---

<ContentLayout 
  {title}
  {section}
  {currentPage}
  {sidebarContent}
  {headings}
>

## 介绍

API密钥是访问大语言模型服务的数字钥匙，是构建AI应用的基础设施。无论是OpenAI的GPT系列、Anthropic的Claude、还是Google的Gemini，都需要通过API密钥进行身份认证和服务调用。

**核心作用**:
- 🔐 **身份认证**: 验证调用者身份
- 💰 **计费管理**: 跟踪使用量和费用  
- 🛡️ **安全控制**: 权限管理和访问控制
- 📊 **使用监控**: 调用统计和性能监控

## API密钥的重要性

### 1. 访问控制核心
API密钥是AI服务的访问凭证，没有有效密钥就无法调用任何AI模型：
```python
import openai

# 配置API密钥
openai.api_key = "sk-xxxxxxxxxxxxxxxxxxxxxxxx"

# 调用API
response = openai.ChatCompletion.create(
    model="gpt-4",
    messages=[{"role": "user", "content": "Hello!"}]
)
```

### 2. 成本管理工具
通过API密钥可以：
- **跟踪使用量**: 每次调用都会计费
- **设置预算限制**: 防止意外高额费用
- **分析使用模式**: 优化调用策略
- **多项目隔离**: 不同项目使用不同密钥

### 3. 安全防护屏障
```bash
# 环境变量方式 (推荐)
export OPENAI_API_KEY="your-api-key"

# 配置文件方式 (注意保护)
echo "OPENAI_API_KEY=your-api-key" > .env

# 错误示例 (绝对不要这样做)
const API_KEY = "sk-xxxxx"; // 硬编码在代码中
```

## 密钥类型与权限

### 主要密钥类型

#### 1. 服务密钥 (Service Keys)
- **全权限**: 可以调用所有可用模型
- **适用场景**: 生产环境、服务器端应用
- **安全级别**: 最高，需要严格保护

#### 2. 项目密钥 (Project Keys)  
- **项目限制**: 只能在特定项目中使用
- **适用场景**: 团队协作、项目隔离
- **安全级别**: 中等，便于管理

#### 3. 用户密钥 (User Keys)
- **个人限制**: 绑定到特定用户账户
- **适用场景**: 个人开发、测试环境
- **安全级别**: 较低，使用灵活

### 权限级别对比

| 权限类型 | Service Key | Project Key | User Key |
|----------|-------------|-------------|----------|
| 模型访问 | ✅ 全部模型 | ✅ 项目模型 | ⚠️ 有限模型 |
| 费用控制 | ✅ 账户级别 | ✅ 项目级别 | ⚠️ 用户级别 |
| 团队共享 | ❌ 不建议 | ✅ 推荐 | ❌ 个人使用 |
| 生产使用 | ✅ 适合 | ✅ 适合 | ❌ 不推荐 |

## 密钥生命周期

### 1. 创建阶段
```mermaid
graph LR
    A[注册账户] --> B[验证身份]
    B --> C[选择套餐]
    C --> D[生成密钥]
    D --> E[配置权限]
```

#### 创建最佳实践
```python
# 密钥命名规范
key_naming_pattern = {
    'environment': 'prod/dev/test',
    'project': 'project_name', 
    'purpose': 'api/webhook/integration',
    'version': 'v1/v2/v3'
}

# 示例: prod-ecommerce-api-v1
key_name = f"{environment}-{project}-{purpose}-{version}"
```

### 2. 配置阶段
```yaml
# API密钥配置文件示例
api_keys:
  openai:
    key: "${OPENAI_API_KEY}"
    org_id: "${OPENAI_ORG_ID}"
    models: ["gpt-4", "gpt-3.5-turbo"]
    rate_limit: 1000  # 每分钟请求数
    
  anthropic:
    key: "${ANTHROPIC_API_KEY}"
    models: ["claude-2", "claude-instant-1"]
    rate_limit: 500
    
  google:
    key: "${GOOGLE_AI_KEY}"
    models: ["gemini-pro"]
    rate_limit: 300
```

### 3. 使用阶段
```python
class APIKeyManager:
    def __init__(self):
        self.keys = self._load_keys()
        self.usage_tracker = UsageTracker()
    
    def get_key(self, provider: str, check_quota: bool = True):
        if check_quota:
            if self.usage_tracker.is_quota_exceeded(provider):
                raise QuotaExceededException(f"{provider} quota exceeded")
        
        return self.keys.get(provider)
    
    def rotate_key(self, provider: str, new_key: str):
        """密钥轮换"""
        old_key = self.keys[provider]
        self.keys[provider] = new_key
        self._backup_old_key(provider, old_key)
        self._update_config(provider, new_key)
```

### 4. 监控阶段
```python
import logging
from datetime import datetime

class KeyUsageMonitor:
    def __init__(self, api_key):
        self.api_key = api_key
        self.logger = logging.getLogger(__name__)
    
    def log_usage(self, endpoint, tokens_used, cost):
        self.logger.info({
            'timestamp': datetime.now().isoformat(),
            'api_key': self.api_key[:8] + "...",  # 只记录前8位
            'endpoint': endpoint,
            'tokens': tokens_used,
            'cost': cost
        })
    
    def check_limits(self):
        """检查使用限制"""
        usage = self.get_current_usage()
        if usage['daily_cost'] > self.daily_limit:
            self.send_alert("Daily cost limit exceeded")
```

### 5. 轮换阶段
```python
# 自动密钥轮换策略
class KeyRotationStrategy:
    def __init__(self):
        self.rotation_interval = 30  # 30天轮换一次
        
    def should_rotate(self, key_age_days):
        return key_age_days >= self.rotation_interval
    
    def rotate_if_needed(self, provider):
        key_info = self.get_key_info(provider)
        
        if self.should_rotate(key_info['age_days']):
            new_key = self.generate_new_key(provider)
            self.update_key(provider, new_key)
            self.notify_rotation_complete(provider)
```

## 常见问题

### 1. 密钥泄露处理
```python
# 密钥泄露应急响应
class KeyCompromiseResponse:
    def handle_compromise(self, compromised_key):
        # 1. 立即撤销密钥
        self.revoke_key(compromised_key)
        
        # 2. 生成新密钥
        new_key = self.generate_replacement_key()
        
        # 3. 更新所有使用该密钥的服务
        self.update_services(new_key)
        
        # 4. 通知相关人员
        self.send_security_alert(compromised_key)
        
        # 5. 审查访问日志
        self.audit_access_logs(compromised_key)
```

### 2. 配额管理
```python
# 智能配额管理
class QuotaManager:
    def __init__(self, monthly_budget=1000):
        self.monthly_budget = monthly_budget
        self.daily_budget = monthly_budget / 30
        
    def check_usage(self):
        current_usage = self.get_current_month_usage()
        remaining_days = self.get_remaining_days()
        
        if remaining_days > 0:
            daily_allowance = (self.monthly_budget - current_usage) / remaining_days
            return min(daily_allowance, self.daily_budget * 1.5)
        
        return 0
    
    def optimize_usage(self):
        """使用优化建议"""
        suggestions = []
        
        if self.is_approaching_limit():
            suggestions.extend([
                "使用更便宜的模型(如gpt-3.5-turbo替代gpt-4)",
                "减少输出长度限制",
                "启用请求缓存",
                "优化prompt减少token使用"
            ])
        
        return suggestions
```

### 3. 性能优化
```python
# API调用优化
class OptimizedAPIClient:
    def __init__(self, api_key):
        self.api_key = api_key
        self.cache = Cache(ttl=3600)  # 1小时缓存
        self.rate_limiter = RateLimiter(requests_per_minute=60)
    
    async def call_api(self, prompt, model="gpt-3.5-turbo"):
        # 检查缓存
        cache_key = hash(f"{prompt}:{model}")
        cached_result = self.cache.get(cache_key)
        if cached_result:
            return cached_result
        
        # 速率限制
        await self.rate_limiter.wait()
        
        # 调用API
        try:
            result = await self._make_request(prompt, model)
            self.cache.set(cache_key, result)
            return result
        except Exception as e:
            self.handle_error(e)
            raise
```

## 快速上手指南

### 步骤1：获取API密钥
```bash
# 1. 访问提供商官网
# OpenAI: https://platform.openai.com/api-keys
# Anthropic: https://console.anthropic.com/
# Google: https://ai.google.dev/

# 2. 创建账户并验证
# 3. 生成API密钥
# 4. 复制并安全存储密钥
```

### 步骤2：环境配置
```bash
# 创建.env文件
echo "OPENAI_API_KEY=your-openai-key" >> .env
echo "ANTHROPIC_API_KEY=your-anthropic-key" >> .env
echo "GOOGLE_AI_KEY=your-google-key" >> .env

# 设置文件权限 (Linux/Mac)
chmod 600 .env

# 加载环境变量
source .env
```

### 步骤3：测试连接
```python
import os
import openai
from dotenv import load_dotenv

# 加载环境变量
load_dotenv()

# 配置API密钥
openai.api_key = os.getenv("OPENAI_API_KEY")

# 测试调用
try:
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "user", "content": "测试API连接"}
        ],
        max_tokens=50
    )
    print("API连接成功!")
    print(response.choices[0].message.content)
except Exception as e:
    print(f"API连接失败: {e}")
```

### 步骤4：实现基础应用
```python
# 简单的AI助手
class SimpleAIAssistant:
    def __init__(self, api_key):
        openai.api_key = api_key
        
    def chat(self, message):
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "你是一个有用的AI助手"},
                {"role": "user", "content": message}
            ],
            temperature=0.7,
            max_tokens=500
        )
        return response.choices[0].message.content

# 使用助手
assistant = SimpleAIAssistant(os.getenv("OPENAI_API_KEY"))
response = assistant.chat("请解释什么是机器学习")
print(response)
```

API密钥管理是AI应用开发的基础技能。正确理解和管理API密钥，不仅能确保应用的正常运行，还能有效控制成本、保障安全，并为应用的扩展打下坚实基础。

</ContentLayout>
